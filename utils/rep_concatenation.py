import torch
from utils.z_matrix import construct_z_matrix, deconstruct_z_matrix
from schnet_flows.schnet_flow_compatibility import collate_samples, flow_to_schnet
from utils.ref_frame import generate_one_ref_frame_rep

def cat_reps(mol_batch, mol_rep, at_rep, schnet_rep, ref_frame_rep, symmetry_tokens, cartesian, device, min_e = True):
    '''
        Auxiliar function to concatenate the representations so that they can be fed into the normalizing flow. 

        Inputs:
            - mol_batch (list of dictionaries): batch of (our) dataset molecules.
            - mol_rep (torch.tensor, size: (n_mol, mol_rep_dim)): molecular representations tensor.
            - at_rep (torch.tensor, size: (n_mol, n_atoms, at_rep_dim)): atomic representations tensor.
            - schnet_rep (torch.tensor, size: (n_mol x n_atoms, schnet_rep_dim) ): schnet representations tensor.
            - ref_frame_rep (torch.tensor, size: (n_mol, n_atoms, 12) ): reference frame representations tensor.
            - symmetry_tokens (torch.tensor, size: (n_mol, n_atoms, 3) ): reference frame representations tensor.
            - cartesian (bool): If false, the model generates cartesian coordinates.
            - device (torch.device)
            - min_e (bool): If true the model learns from QM9 minimal energy conformations, otherwise the model learns from md simulated conformations

        Outputs:
            - flow_input ( torch.tensor, size: (n_mol x n_atoms, rep_size) )
    '''
    n_atoms = [ len( mol['atoms'] ) for mol in mol_batch ]
    if min_e:
        conf_name = 'me_conformation'
    else:
        conf_name = 'md_conformations'
    
    if cartesian: #This part needs to be updated
        raise NotImplementedError
        
    else: # For IC:
        d_input = torch.empty(0, dtype=torch.float32).to(device)
        da_input = torch.empty(0, dtype=torch.float32).to(device)
        dat_input = torch.empty(0, dtype=torch.float32).to(device)
        first_idx = 0

        for i_mol, mol_sample in enumerate(mol_batch):
            n_conf = mol_sample[conf_name].size()[0]
            mol_mol_rep = torch.empty(0, dtype=torch.float32).to(device)
            for _ in range( (n_atoms[i_mol] - 1) ): mol_mol_rep = torch.cat( (mol_mol_rep, mol_rep[i_mol].unsqueeze(dim = 0)) , dim = 0)
            #mol_at_rep = torch.empty(0, dtype=torch.float32).to(device)
            #for _ in range(n_conf): mol_at_rep = torch.cat( (mol_at_rep, at_rep[i_mol, 1:n_atoms[i_mol]]), dim = 0 )
            mol_at_rep = at_rep[i_mol, 1:n_atoms[i_mol]]

            for i_conf in range(n_conf):            
                
                final_idx = first_idx + n_atoms[i_mol] - 2

                #This could be paralellized and is already computed in generate_ref_frame_rep: optimizable.
                z_matrix = construct_z_matrix( X = mol_sample[conf_name][i_conf], ref_atoms = mol_sample['ref_atoms'], placing_order = list(range(n_atoms[i_mol])) )
                z_matrix[z_matrix != z_matrix] = 0. #Protection for nans

                mol_schnet_rep = schnet_rep[first_idx:final_idx + 1]
                mol_ref_frame_rep = ref_frame_rep[i_mol][i_conf]
                mol_symmetry_tokens = symmetry_tokens[i_mol][i_conf]

                mol_flow_input = torch.cat( (mol_mol_rep.to(device), mol_at_rep.to(device), mol_schnet_rep.to(device), mol_ref_frame_rep.to(device), mol_symmetry_tokens.to(device), z_matrix.to(device)), dim = 1 )
                d_input = torch.cat( (d_input, mol_flow_input[0].unsqueeze(dim = 0).unsqueeze(dim = 0)) , dim = 0)
                if n_atoms[i_mol] > 2:
                    da_input = torch.cat( (da_input, mol_flow_input[1].unsqueeze(dim = 0).unsqueeze(dim = 0)) , dim = 0)
                if n_atoms[i_mol] > 3:
                    dat_input = torch.cat( (dat_input, mol_flow_input[2:].unsqueeze(dim=1)), dim = 0 )

                first_idx = final_idx + 1

        if d_input.numel() == 0:
            d_input = None
        if da_input.numel() == 0:
            da_input = None
        if dat_input.numel() == 0:
            dat_input = None

        return d_input, da_input, dat_input

def cat_second_atom_representation(mol_batch, mol_rep, at_rep, n_conf, device):
    '''
        Auxiliar function to concatenate the representations of the second atoms so that they can be fed into the normalizing flow. This function is used for energy-based learning. 

        Inputs:
            - mol_batch (list of dictionaries): batch of (our) dataset molecules.
            - mol_rep (torch.tensor, size: (n_mol, mol_rep_dim)): molecular representations tensor.
            - at_rep (torch.tensor, size: (n_mol, n_atoms, at_rep_dim)): atomic representations tensor.
            - n_conf (int): number of conformations generated by the model for every molecule.
            - device (torch.device)

        Outputs:
            - flow_input ( torch.tensor, size: (n_mol x n_atoms, rep_size) )
    '''
    ref_1 = torch.tensor([0,0,0,1,0,0,0,1,0,0,0,1], dtype = torch.float32, device = device)
    cat_mol_rep = torch.empty(0, dtype=torch.float32, device = device) #Changes because number of atoms is not the same in general
    cat_at_rep = torch.empty(0, dtype=torch.float32, device = device)
    cat_ref_frame_rep = torch.empty(0, dtype=torch.float32, device = device)
    cat_symmetry_token = torch.empty(0, dtype=torch.float32, device = device)
    schnet_inputs = []

    for i_mol, sample in enumerate(mol_batch):
        for i_conf in range(n_conf):
            cat_mol_rep = torch.cat( (cat_mol_rep, mol_rep[i_mol].unsqueeze(dim = 0)), dim = 0 )
            cat_at_rep = torch.cat( (cat_at_rep, at_rep[i_mol][1].unsqueeze(dim = 0)), dim = 0 ) 
            cat_ref_frame_rep = torch.cat( (cat_ref_frame_rep, ref_1.unsqueeze(dim = 0)), dim = 0 )
            atoms = torch.tensor( [sample['atoms'][0]], dtype = torch.long, device = device )
            positions = torch.zeros( (1,3) , dtype = torch.float32, device = device )
            cat_symmetry_token = torch.cat( (cat_symmetry_token, positions), dim = 0 )
            schnet_inputs.append(flow_to_schnet(atoms, positions, device))

    schnet_inputs = collate_samples(schnet_inputs)
    
    return cat_mol_rep, cat_at_rep, schnet_inputs, cat_ref_frame_rep, cat_symmetry_token


def cat_third_atom_representation(mol_batch, mol_rep, at_rep, conformations, n_conf, device):
    '''
        Auxiliar function to concatenate the representations so that they can be fed into the normalizing flow. This function is used for energy-based learning. 

        Inputs:
            - mol_batch (list of dictionaries): batch of (our) dataset molecules.
            - mol_rep (torch.tensor, size: (n_mol, mol_rep_dim)): molecular representations tensor.
            - at_rep (torch.tensor, size: (n_mol, n_atoms, at_rep_dim)): atomic representations tensor.
            - conformations (list of n_mol torch.tensors of size (n_conf, n_atoms, 3) ): zero-padded tensors with the positions the previously placed atoms
            - n_conf (int): number of conformations generated by the model for every molecule.
            - device (torch.device)

        Outputs:
            - flow_input ( torch.tensor, size: (n_mol x n_atoms, rep_size) )
    '''
    n_atoms = [ len( mol['atoms'] ) for mol in mol_batch ]
    cat_mol_rep = torch.empty(0, dtype=torch.float32, device = device)
    cat_at_rep = torch.empty(0, dtype=torch.float32, device = device)
    cat_ref_frame_rep = torch.empty(0, dtype=torch.float32, device = device)
    cat_symmetry_token = torch.empty(0, dtype=torch.float32, device = device)
    schnet_inputs = []

    for i_mol, sample in enumerate(mol_batch):
        if n_atoms[i_mol] > 2:
            for i_conf in range(n_conf):
                cat_mol_rep = torch.cat( (cat_mol_rep, mol_rep[i_mol].unsqueeze(dim = 0)), dim = 0 )
                cat_at_rep = torch.cat( (cat_at_rep, at_rep[i_mol][2].unsqueeze(dim = 0)), dim = 0 ) 
                d12 = conformations[i_mol][i_conf, 0, 0].item()
                ref_2 = torch.tensor([d12,0,0,1,0,0,0,1,0,0,0,1], dtype = torch.float32, device = device)
                cat_ref_frame_rep = torch.cat( (cat_ref_frame_rep, ref_2.unsqueeze(dim = 0)), dim = 0 )
                atoms = sample['atoms'][0:2]
                #We need cc here!
                positions = torch.cat( (torch.zeros( (1,3) , dtype = torch.float32, device = device ), conformations[i_mol][i_conf, 0, :].unsqueeze( dim = 0) ), dim = 0 )
                cat_symmetry_token = torch.cat( (cat_symmetry_token, torch.mean(positions, dim = 0).unsqueeze( dim = 0) ), dim = 0 )
                schnet_inputs.append(flow_to_schnet(atoms, positions, device))

    schnet_inputs = collate_samples(schnet_inputs)
    
    return cat_mol_rep, cat_at_rep, schnet_inputs, cat_ref_frame_rep, cat_symmetry_token

def cat_atom_representation(i_atom, mol_batch, mol_rep, at_rep, conformations, n_conf, device):
    '''
        Auxiliar function to concatenate the representations so that they can be fed into the normalizing flow. This function is used for energy-based learning. 

        Inputs:
            - mol_batch (list of dictionaries): batch of (our) dataset molecules.
            - mol_rep (torch.tensor, size: (n_mol, mol_rep_dim)): molecular representations tensor.
            - at_rep (torch.tensor, size: (n_mol, n_atoms, at_rep_dim)): atomic representations tensor.
            - conformations (list of n_mol torch.tensors of size (n_conf, n_atoms, 3) ): zero-padded tensors with the positions the previously placed atoms
            - n_conf (int): number of conformations generated by the model for every molecule.
            - device (torch.device)

        Outputs:
            - flow_input ( torch.tensor, size: (n_mol x n_atoms, rep_size) )
    '''
    n_atoms = [ len( mol['atoms'] ) for mol in mol_batch ]
    cat_mol_rep = torch.empty(0, dtype=torch.float32, device = device)
    cat_at_rep = torch.empty(0, dtype=torch.float32, device = device)
    cat_ref_frame_rep = torch.empty(0, dtype=torch.float32, device = device)
    cat_symmetry_token = torch.empty(0, dtype=torch.float32, device = device)
    schnet_inputs = []
    for i_mol, sample in enumerate(mol_batch):
        if n_atoms[i_mol] > i_atom:
            for i_conf in range(n_conf):
                cat_mol_rep = torch.cat( (cat_mol_rep, mol_rep[i_mol].unsqueeze(dim = 0)), dim = 0 )
                cat_at_rep = torch.cat( (cat_at_rep, at_rep[i_mol][i_atom].unsqueeze(dim = 0)), dim = 0 )
                positions = deconstruct_z_matrix( conformations[i_mol][i_conf, 0:i_atom-1, :].clone(), sample['ref_atoms'][0:i_atom].copy(), loss=False ) #In cartesian coordinates. This can be made more efficient, only computing the position of the last placed atom.
                # This can be parallelized!
                x_ref = positions[sample['ref_atoms'][i_atom].copy()].clone()
                ref_frame_rep = generate_one_ref_frame_rep( x_ref.clone() )                            
                cat_ref_frame_rep = torch.cat( (cat_ref_frame_rep, ref_frame_rep.clone()), dim = 0 )
                cat_symmetry_token = torch.cat( (cat_symmetry_token, torch.mean(positions, dim = 0).unsqueeze( dim = 0) ), dim = 0 )
                atoms = sample['atoms'][0:i_atom]
                schnet_inputs.append(flow_to_schnet(atoms.clone(), positions.clone(), device))

    schnet_inputs = collate_samples(schnet_inputs)

    return cat_mol_rep, cat_at_rep, schnet_inputs, cat_ref_frame_rep, cat_symmetry_token
